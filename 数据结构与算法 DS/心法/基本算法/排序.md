常见 x 种排序:

基于数组

| 算法     | 复杂度   | 基于比较(不重要) | 稳定 | 原地 | 场景 |
| -------- | -------- | ---- | ---- | -------- | -------- |
| 冒泡排序 | o(n2)    | 是 | 是 | 是 | 小规模数据 |
| 插入排序(最常用) | o(n2)    | 是 | 是 | 是 | 小 |
| 选择排序 | o(n2)    | 是 | 否 | 是 | 小 |
| 希尔排序(插入排序的优化) | o(n2)    |      |      |  |  |
| 归并排序 | o(nlogn) | 是 | 是 | 否o(n) | 大 |
| 堆排     | o(nlogn)    |      |      |  |  |
| 快排     | o(nlogn) | 是 |      |  | 大 |
| 基数排序 | o(n)     | 否 |      |  |  |
| 计数排序 | o(n)     |      |      |  |  |
| 桶排序   | o(n)     | 否 |      |  |  |

## 冒泡排序  

每次遍历, 把最大的冒泡到最上面

原子操作: 比较 交换(=逆序度)

```
有序度
有序元素对：a[i] <= a[j], 如果i < j。
满有序度(n*(n-1)/2)
逆序度: 逆序度 = 满有序度 - 有序度
```



## 插入排序

每次把最小的插入到该放的位置, 后面的依次移动

原子操作: 比较 移动

冒泡和插入的区别

```

冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```



## 选择排序

每次选未排序区间最小的交换到已排序区间的末尾

原子操作: 比较 交换

## 引用

https://juejin.im/post/57dcd394a22b9d00610c5ec8?from=timeline&isappinstalled=0

算法动态过程: https://visualgo.net/en

希尔排序: [https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F](https://zh.wikipedia.org/wiki/希尔排序)



## 在 o(n)内找到第 K 大的元素



## 原地排序

(临时空间量级是否为 1)